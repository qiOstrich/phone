Python1905 齐明祥
day-01	认识千峰，学习千峰生活规则，违反学习手册扣分罚钱
	队名：明日之猿
	队训：今日之猩，明日之猿，学习派森，成就自我
typora使用
1.

从一个#号开始，每加一个#为某级标题，最多六级标题如（# 第一章）
2.**中间内容自动斜体
，****中间内容自动加粗。
3.> 内容 会被作为说明
4.！【】（）括号中可以插入指定的图片。
5.・・・（~键）内容为代码・・・
6.‘内容’ 中间符号不被转换为指定功能。
7.+ - 可以引出无序列表，再分可用Tab键分下级列表
8.表格可以找菜单栏添加
9.可以导出为多格式文件，html目录关联需要node 再装gitbook插件：npm install gitbook-cli -g
summary中链接直接使用文件名.md 链接
gitbook build --gitbook=2.6.7	必须使用node6版本


cmd命令：pip install ipython 下载包 

周三讲师测评 每月一次教师测评(班主任 就业老师)
下午上课时间改为1.40分
 pycharm：ctrl D 自动复制上一行代码

day0716:
	注释的使用：#注释一行，'''也是注释，优点在于可以换行'''

	定义变量：使用等于号 = 给变量进行赋值

	数据类型：str，字符串   int，整型   float，浮点型   bool，布尔型   None，空值   types，二进制类型   list，列表  tuple，元组  dict，字典 set，无序不重复列（相等于dict中的key）

	在Python3中long类型已经废弃，Python2中input输入字符串需要加引号‘’/"" raw_input相当于python3中的input，python2默认不支持中文，需要#-*- conding：utf-8 -*-，python2中的print可以不加括号，而python3不行

	数据类型转换：str（ele）将ele转换为字符串	int（ele，8/16）将ele转换为8或16进制数，不填默认转为十进制数	float（ele）将ele转为浮点型	bool（ele）将ele转为bool型

	标识符和关键字：命名时有规范和规则，规则必须遵守，不然报错	规范建议遵守，虽然不会直接报错，但是对程序有影响	规则:1.使用字母，数字，下划线命名，数字不能开头	2.不能使用Python中具有特殊含义的词（python自带的属性）	3.严格区分大小写	规范：1.尽量使用通俗易懂的英文单词或词组进行命名	2.使用大小驼峰法命名	3.支持中文命名，但是不建议使用中文命名变量	4.避免和其他属性重名

day0717：
	算术运算符：+ - * / % // ** 分别是加，减，乘，除，取余（模），取整除，幂运算	有的运算字符不止能对整型进行运算，也可以对其他数据类型进行运算

	赋值运算符：等于号= 给变量进行赋值,是浅拷贝

	复合运算符：+= -= *= /= %= //= **= 对同名变量进行

	比较运算符：< > <= >= !=  == is	<> 分别是小于号，大于号，小于或等于号，大于或等于号，不等于号，判断内容是否相等，判断地址是否相等，不等于号（python3中已经舍弃）

	逻辑运算符：not and or  返回值是bool 

	位运算符：   & | ^ ~ >> << 	分别是与运算，或运算，异或运算，取反，右移，左移	都是将数据转化为二进制进行操作

	运算优先级：使用（）提高运算优先级	需要注意的是not>and>or

	

day0718:
	条件判断语句：if条件判断语句 可以使用 if elif else 进行多重条件判断

	循环语句：1.while 循环语句 可以使用continue进行插入，使用break进行中断循环	
		2.for in 循环，可以配合range（）进行使用，也可以配合enumerate（）函数进行使用	循环也可以用else语句
	
	字符串的使用详解：1.定义：可以用一对引号，也可以用三队引号进行换行，在字符串中输入\\代表输入一个反斜杠，第一个反斜杠是转义字符，第二个才是说明输出是反斜杠
		python2中可以使用``定义字符串，但是在Python3中已经废除
		\r输入回车   \n 换行符  \t 输出tab键	\r\n也是换行符，可以跨平台使用，建议使用
		在字符串前加r‘str’代表纯字符串，字符不需要转义
		2.下标的使用： a[0]，代表字符串的第一个字符
		3.字符串切片：a[n:m:s] n为开始的下标，m为结束钱的下标，s是步数step表示切割的间隔，s可以是负数，表示反向切片

day0719:
	循环语句的使用： for in 可迭代对象（__iterable）：
















day0725:
	参数传值和数据类型：变量间赋值时将原变量的数据地址传给新变量。对于可变类型，改变其中一个数据，内存中的数据会改变，那么指向此数据的变量使用时数据都会改变；对于不可变类型，赋值就是将变量指向一个内存空间，重新赋值就会指向别的内存空间。
	函数的参数与return的注意事项：
		1.return后面可以不写语句，表示函数结束
		2.pass也表示语句结束
	递归函数：函数自己调用自己，形成递归，求斐波那契数列的代码：
	def fibnacci_list(n):
    		resultList = 1
    		if n == 1:
        		return 1
    		elif n == 2:
        		return 1
    		elif n > 2:
        		resultList = fibnacci_list(n - 1) + fibnacci_list(n - 2)

    		return resultList

	列表推导式：轻量级循环创建列表；
		# 列表推导式:将1到100的列表分为三个数为一个列表的二维列表
		a = [x for x in range(1, 101)]
		b = [a[x:x + 3] for x in range(0, len(a), 3)]
		# 将1到100的数分为100个列表
		c = [a[x:x + 1] for x in range(0, len(a), 1)]
		在圆括号内些表达式会得到一个生成器，next（）方法可以得到生成器生成的生成值（逐个返回）。

	在python中，函数也是一个数据，可以作为参数，也可以作为返回值。

	闭包：函数内定义的函数，返回值是自己。这个函内部函数就是闭包。
		在闭包内使用外函数的变量要声明nonlocal 变量名 然后才能用
	装饰器：@函数名 这个语法相当于调用了这个函数，并把被装饰的函数传递给这个函数作为参数
	装饰语法：@装饰函数
			def 函数:语句
		要注意的是，装饰函数需要参数，装饰函数的内函数需要执行参数对应的函数
		内容实质是在装饰函数内定义内函数调用装饰函数的参数（），这是一个被装饰函数，装饰函数的返回值是内函数。
		装饰器语法的作用：1.会调用装饰函数	2.把被装饰函数作为参数传递给装饰函数	3.装饰器需要返回一个函数，此时的被装饰函数已经被替换成装饰函数的内函数	4.内函数最终需要调用外函数的参数（）
	使用装饰器装饰的函数已经被装饰器内函数替代。
	有返回值的被装饰函数在定义时，装饰器内函数要返回被调用的函数
		@装饰器（参数），在添加一层装饰,在调用装饰器时，参数是被装饰函数的权限，装饰器只需调用全局权限与之判断

day0726：	
	迭代器浅谈：iterable，可迭代的 在Python中有迭代器，将可迭代对象注意迭代（取出）通过语句 ：isinstance（迭代对象，Iterable）可以判断对象是否真的可以迭代，返回一个bool值
		在类中需要定义一个迭代方法：def __iter__(self):pass ; 这样这个类就可迭代
		列表是一个可迭代对象，在系统模块中有list class，其中就有迭代方法__iter__(self,*args,**kwargs)
		实现for in 循环原理：本质是调用了迭代对象的迭代器中的next（）方法。 iter（）方法可以返回对象的迭代器，使用next（）方法可以拿到迭代器中的元素，但迭代器元素取完，再使用next（）就会报错。
		迭代器也是可迭代的。
	
	filter（function or None，iterable），返回满足函数的迭代器中的数据。
	
	list会将数据保存在存储器，而迭代器会将数据产生算法，使用时返回算法实现后的数据。

	内置模块：
		random模块：导入后，用方法的到随机数
		math模块：导入后，可以使用数学函数（方法）
	os模块：os.removedirs("文件夹名")删除文件夹
		os.getenv("path")得到path的环境变量
		os.makedirs（‘文件名’）创建一个python package文件夹
		os.rename('原文件名','改成文件名'）重命名文件夹名
		cmd：dir读取当前目录文件名
		os.chdir(‘../’)返回上级目录
		os.chdir(‘../text’)进入上级目录中的下级文件夹，文件夹名是text
		os.listdir()列出当前目录文件名
		os.getcwd（）返回当前目录名
		os.envron()得到所有的环境变量及路径
		os.path.abspath(‘文件名’)拿到文件名的绝对路径
		相对文件：与当前文件同文件夹的路径
		os.path.exsit(‘文件名’)是否在当前文件夹中，返回值是bool
		os.path.isdir（‘文件名’）是否为文件夹
		os.path.isfile（‘文件名’）是否为文件
	time模块：
		time.time（）获取从1970-1-1UTC到现在的时间（second-北京时间八点整）

day0729:
	面向过程编程：
		需要实现所有需求的步骤。
		注重步骤与过程，不注重分工。
		需求复杂，代码也复杂。
		编程难度高。
	面向对象编程：
		在完成需求前需要分工（确认职责）
		根据职责确定不同的对象，将方法封装在对象里。
	魔法方法：使用双下划线开始和结尾的方法。
		__init__:初始化方法
		__str__:打印对象名时的返回值。必须有返回值。
		__del__:对象调用完成之后自动删除内存，之后进行的操作。	

day0730:
	__new__(cls,*args,**kwargs)方法：申请一段内存空间
	实际是返回了 object.__new__(cls)
	__init__方法：初始化内存，构造一个对象
	
	# 私有属性和私有方法 在属性和方法前加双下划线
    
	继承：在定义类的时候括号中写继承的父类，可以写多个（father1，father2，……）
	子类可以调用继承父类的非私有方法，非私有属性
	即使是私有方法依然可以使用_类名.__属性名进行查看（非常不建议使用这个调用方法）

	# 重写：子类中定义父类已有的方法叫重写，子类在进行调用的时候会使用自己方法，而不用父类中的同名方法
	# 私有属性和方法的继承特点：不继承


	多态：继承同一个父类的子类对父类的方法进行重写，在调用时使用不同子类调用方法时进行不同的操作是为多态
	子类若不进行重写，那么子类在调用这个方法时使用父类中的方法


	实例属性和类属性
	类可以不定义对象，使用类名进行调用属性，类改变属性会将之后的对象中的属性也改变
	实例对象进行调用属性和方法时不会对原类有影响，除非类中有方法对自己（cls）进行了改变


	类方法和静态方法：
	类方法：
	@classmethod
	定义方法至少需要有cls参数
	使用这个装饰器定义的类是类方法，方法被调用改变的是类中的属性和方法，使用对象也可以调用，改变的依然是类，对象自然随之改变
	
	静态方法：
	@staticmethod
	使用这个装饰器定义的类是静态方法，静态方法可以没有任何参数，类和对象都可以调用
	在类中定义类方法，静态方法，普通方法时会自动覆盖，调用最后一个定义出的方法
	
	__new__方法的使用：创建内存的函数，在定义对象时，初始化之前会自动调用这个方法
	目的就是为对象开辟一个独立的内存空间，可以重写实现多对象只分配一个内存

day0731:

	import 模块名
	from 模块名 import 功能名
	from 模块名 import *
	import 模块名 as 别名
	from 模块名 import 功能名 as 别名

线程注意事项，线程间数据共享，线程通信只需要避免读脏数据。
使用lock=threading.Lock（）可以实现数据上锁，with lock：语句会自动解锁，
lock.acquire()请求锁，需要手动解锁 :lock.release() 
with语句和acquire语句之后写需要上锁的数据操作 
线程的局部数据需要声明local对象：
	local = threading.Local(),在函数内调用直接给对象添加属性。不同的函数之间不能共享属性。

进程注意事项，进程间数据不共享，即使是全局变量也会各自重新赋值调用，
进程间通信需要在进程之间传递参数，在创建进程中args=()进行传参
queueu（）队列，实现生产者消费者，既生产才能消费，实现进程和线程的多任务分先后。




























